#!/usr/bin/env bash
### DESCRIPTION: Command discovery caching for land-the-plane workflow
# Usage: autoland --list | --cache <source> <category> '<commands_json>' | --clear

set -euo pipefail

# Constants
CACHE_DIR=".tmp"
CACHE_FILE="${CACHE_DIR}/autoland.json"
DEFAULT_CACHE='[]'

# Ensure cache directory exists
mkdir -p "${CACHE_DIR}"

# Platform-specific SHA-1 command
if command -v sha1sum >/dev/null 2>&1; then
    SHA1_CMD="sha1sum"
elif command -v shasum >/dev/null 2>&1; then
    SHA1_CMD="shasum -a 1"
else
    echo "Error: SHA-1 command not found (sha1sum or shasum)" >&2
    exit 1
fi

# Check for jq dependency
if ! command -v jq >/dev/null 2>&1; then
    echo "Error: jq not found" >&2
    exit 1
fi

# Compute SHA-1 hash of a file
compute_hash() {
    local file="$1"
    if [[ -f "$file" ]]; then
        $SHA1_CMD "$file" | cut -d' ' -f1
    else
        echo "missing"
    fi
}

# Read cache file, return default if missing
read_cache() {
    if [[ -f "$CACHE_FILE" ]]; then
        cat "$CACHE_FILE"
    else
        echo "$DEFAULT_CACHE"
    fi
}

# Write cache file atomically
write_cache() {
    local content="$1"
    local tmp_file="${CACHE_FILE}.tmp"
    echo "$content" > "$tmp_file"
    mv "$tmp_file" "$CACHE_FILE"
}

# Validate JSON array of strings
validate_commands_json() {
    local json="$1"
    if ! echo "$json" | jq -e 'type == "array" and all(type == "string")' >/dev/null 2>&1; then
        echo "Error: commands_json must be a JSON array of strings" >&2
        return 1
    fi
    return 0
}

# List valid cached commands
list_commands() {
    local cache_content
    cache_content=$(read_cache)
    local updated=false
    local valid_entries=()
    local stale_sources=()
    
    # Parse cache as array
    local length
    length=$(echo "$cache_content" | jq 'length')
    
    for ((i=0; i<length; i++)); do
        local entry
        entry=$(echo "$cache_content" | jq ".[$i]")
        local source
        source=$(echo "$entry" | jq -r '.source')
        local cached_hash
        cached_hash=$(echo "$entry" | jq -r '.hash')
        local command
        command=$(echo "$entry" | jq -r '.command')
        local category
        category=$(echo "$entry" | jq -r '.category')
        
        local current_hash
        current_hash=$(compute_hash "$source")
        
        if [[ "$cached_hash" == "$current_hash" ]]; then
            # Hash matches, keep entry
            valid_entries+=("$entry")
        else
            # Hash mismatch, remove entry
            updated=true
            # Track stale source
            stale_sources+=("$source")
        fi
    done
    
    # If entries were removed, update cache
    if [[ "$updated" == true ]]; then
        local new_cache
        new_cache=$(printf '%s\n' "${valid_entries[@]}" | jq -s '.')
        write_cache "$new_cache"
    fi
    
    # Output based on state
    if [[ ${#valid_entries[@]} -eq 0 ]]; then
        if [[ ${#stale_sources[@]} -gt 0 ]]; then
            echo "Error: All cached commands are stale. The following source files have changed:" >&2
            printf '%s\n' "${stale_sources[@]}" | sort -u | while IFS= read -r source; do
                echo "  - $source" >&2
            done
            echo >&2
            echo "Please rediscover CI commands for these sources and recache them with:" >&2
            echo "  autoland --cache <source> <category> '<commands_json>'" >&2
            exit 1
        else
            # Empty cache, valid state
            echo "No cached commands found. Please load the 'land-the-plane' skill to discover CI commands."
            exit 0
        fi
    elif [[ ${#stale_sources[@]} -gt 0 ]]; then
        # Some entries are valid, but some sources are stale
        echo "Warning: Some cached commands are stale. The following source files have changed:" >&2
        printf '%s\n' "${stale_sources[@]}" | sort -u | while IFS= read -r source; do
            echo "  - $source" >&2
        done
        echo >&2
        echo "Please rediscover CI commands for these sources and recache them with:" >&2
        echo "  autoland --cache <source> <category> '<commands_json>'" >&2
        echo >&2
        echo "Using valid cached commands for other sources:" >&2
        # Output valid entries (JSON) to stdout
        printf '%s\n' "${valid_entries[@]}" | jq -s '.'
    else
        # All entries valid
        printf '%s\n' "${valid_entries[@]}" | jq -s '.'
    fi
}

# Cache commands for a source
cache_commands() {
    local source="$1"
    local category="$2"
    local commands_json="$3"
    
    # Validate commands JSON
    if ! validate_commands_json "$commands_json"; then
        return 1
    fi
    
    # Compute hash of source file
    local hash
    hash=$(compute_hash "$source")
    
    # Read existing cache
    local cache_content
    cache_content=$(read_cache)
    
    # Parse commands from JSON
    local commands
    commands=$(echo "$commands_json" | jq -c '.[]')
    
    # Process each command
    while IFS= read -r command; do
        # Remove quotes from command
        command=$(echo "$command" | tr -d '"')
        
        # Check if entry already exists (deduplicate by source+command+category)
        local exists
        exists=$(echo "$cache_content" | jq --arg s "$source" --arg c "$command" --arg g "$category" \
            '[.[] | select(.source == $s and .command == $c and .category == $g)] | length > 0')
        
        if [[ "$exists" == "false" ]]; then
            # Create new entry
            local new_entry
            new_entry=$(jq -n \
                --arg source "$source" \
                --arg hash "$hash" \
                --arg command "$command" \
                --arg category "$category" \
                '{source: $source, hash: $hash, command: $command, category: $category}')
            
            # Append to cache
            cache_content=$(echo "$cache_content" | jq ". + [$new_entry]")
        fi
    done <<< "$commands"
    
    # Write updated cache
    write_cache "$cache_content"
}

# Clear cache
clear_cache() {
    if [[ -f "$CACHE_FILE" ]]; then
        rm "$CACHE_FILE"
        echo "Cache cleared"
    else
        echo "Cache file does not exist"
    fi
}

# Print usage
usage() {
    cat <<EOF
Usage: $(basename "$0") [OPTION]

Command discovery caching for land-the-plane workflow.

Options:
  --list                    List valid cached commands as JSON array
  --cache SOURCE CATEGORY COMMANDS_JSON
                            Cache commands for a source
                            SOURCE: path to source file (e.g., .github/workflows/ci.yml)
                            CATEGORY: command category (lint, test, typecheck, format, build)
                            COMMANDS_JSON: JSON array of command strings
                            Example: --cache Makefile build '["make build"]'
  --clear                   Clear cache file
  --help                    Show this help message

Output:
  --list outputs JSON array of objects with fields:
    {
      "source": "path/to/source",
      "hash": "sha1_hash",
      "command": "shell command",
      "category": "category"
    }

  Returns an instruction to load the 'land-the-plane' skill if no valid cached commands.

Exit codes:
  0 - Success
  1 - Error (invalid arguments, missing dependencies)
EOF
}

# Main argument parsing
main() {
    if [[ $# -eq 0 ]]; then
        usage
        exit 1
    fi
    
    case "$1" in
        --list)
            list_commands
            ;;
        --cache)
            if [[ $# -lt 4 ]]; then
                echo "Error: --cache requires SOURCE CATEGORY COMMANDS_JSON arguments" >&2
                usage
                exit 1
            fi
            cache_commands "$2" "$3" "$4"
            ;;
        --clear)
            clear_cache
            ;;
        --help|-h)
            usage
            ;;
        *)
            echo "Error: Unknown option $1" >&2
            usage
            exit 1
            ;;
    esac
}

main "$@"